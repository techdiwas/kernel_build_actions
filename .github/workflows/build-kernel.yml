name: Kernel Build Pipeline

on:
  workflow_dispatch:
    inputs:
      release_build:
        description: 'Create a release'
        type: boolean
        default: false
  # Uncomment to enable scheduled builds
  # schedule:
  #   - cron: "0 0 * * 0"  # Weekly builds on Sunday at midnight

jobs:
  parse-configs:
  name: Parse Configuration Files
  runs-on: ubuntu-latest
  outputs:
    CONFIGS: ${{ steps.generate-matrix.outputs.CONFIGS }}
    BUILD_DATE: ${{ steps.build-info.outputs.date }}
  steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Generate Build Matrix
      id: generate-matrix
      run: |
        echo "CONFIGS<<EOF" >> $GITHUB_OUTPUT
        jq -s '[.[][]]' kernel/configs/*.config.json >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
    
    - name: Set Build Information
      id: build-info
      run: |
        echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT

  build-kernel:
    name: Build Kernel - ${{ matrix.CONFIG.kernelSource.name }}
    needs: parse-configs
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        CONFIG: ${{ fromJSON(needs.parse-configs.outputs.matrix) }}
    
    env:
      # Build configuration
      BUILD_DATE: ${{ needs.parse-configs.outputs.build_date }}
      BUILD_ID: ${{ needs.parse-configs.outputs.build_id }}
      
      # Kernel configuration
      KERNEL_NAME: ${{ matrix.CONFIG.kernelSource.name }}
      KERNEL_REPO: ${{ matrix.CONFIG.kernelSource.repo }}
      KERNEL_BRANCH: ${{ matrix.CONFIG.kernelSource.branch }}
      KERNEL_DEVICE: ${{ matrix.CONFIG.kernelSource.device }}
      KERNEL_DEFCONFIG: ${{ matrix.CONFIG.kernelSource.defconfig }}
      
      # Feature flags
      ENABLE_CCACHE: ${{ matrix.CONFIG.enableCcache }}
      ENABLE_KERNELSU: ${{ matrix.CONFIG.enableKernelSU }}
      USE_ANYKERNEL3: ${{ matrix.CONFIG.AnyKernel3.use }}
      CREATE_RELEASE: ${{ matrix.CONFIG.AnyKernel3.release && github.event.inputs.release_build != 'false' }}
      
      # Directories
      WORKSPACE: ${{ github.workspace }}
      OUT_DIR: ${{ github.workspace }}/out
      CCACHE_DIR: ${{ github.workspace }}/ccache
      
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Build Environment
        uses: ./.github/actions/setup-build-env
        
      - name: Increase Swap Space
        uses: pierotofy/set-swap-space@master
        with:
          swap-size-gb: 10
      
      - name: Setup CCache
        if: ${{ env.ENABLE_CCACHE == 'true' }}
        id: ccache-setup
        run: |
          mkdir -p ${{ env.OUT_DIR }} ${{ env.CCACHE_DIR }}
          ccache -o compression=false -o cache_dir=${{ env.CCACHE_DIR }}
          echo "config_hash=$(echo -n '${{ toJSON(matrix.CONFIG) }}' | shasum -a 1 | cut -d ' ' -f1)" >> $GITHUB_OUTPUT
      
      - name: Cache Build Artifacts
        if: ${{ env.ENABLE_CCACHE == 'true' }}
        uses: actions/cache@v3
        with:
          path: |
            ${{ env.OUT_DIR }}
            ${{ env.CCACHE_DIR }}
          key: build-${{ env.KERNEL_NAME }}-${{ steps.ccache-setup.outputs.config_hash }}-${{ env.BUILD_DATE }}
          restore-keys: |
            build-${{ env.KERNEL_NAME }}-${{ steps.ccache-setup.outputs.config_hash }}-
            build-${{ env.KERNEL_NAME }}-
      
      - name: Clone Kernel Source
        run: |
          git clone --recursive --depth=1 -j $(nproc) --branch ${{ env.KERNEL_BRANCH }} ${{ env.KERNEL_REPO }} ${{ env.KERNEL_NAME }}
      
      - name: Setup Toolchains
        id: toolchains
        run: |
          # Create a function to process toolchains
          setup_toolchain() {
            local toolchain=$1
            local name=$(echo $toolchain | jq -r '.name')
            
            # Handle URL-based toolchains
            if echo $toolchain | jq -e 'has("url")' > /dev/null; then
              local url=$(echo $toolchain | jq -r '.url')
              mkdir -p "$name"
              
              echo "Downloading toolchain: $name from $url"
              wget -q "$url" -O toolchain.archive
              
              case "$url" in
                *.zip) unzip -q toolchain.archive -d $name ;;
                *.tar) tar xf toolchain.archive -C $name ;;
                *.tar.gz|*.tgz) tar xzf toolchain.archive -C $name ;;
                *.rar) unrar x toolchain.archive $name ;;
                *) echo "Unsupported archive format from $url" && exit 1 ;;
              esac
              rm toolchain.archive
            
            # Handle Git-based toolchains
            else
              local repo=$(echo $toolchain | jq -r '.repo')
              local branch=$(echo $toolchain | jq -r '.branch')
              echo "Cloning toolchain: $name from $repo"
              git clone --recursive --depth=1 -j $(nproc) --branch $branch $repo $name
            fi
            
            # Add binary paths to PATH
            jq -r '.binaryEnv[]' <<< "$toolchain" | while read -r subPath; do
              echo "${{ env.WORKSPACE }}/$name/$subPath" >> $GITHUB_PATH
            done
          }
          
          # Process each toolchain
          echo '${{ toJSON(matrix.CONFIG.toolchains) }}' | jq -c '.[]' | while read -r toolchain; do
            setup_toolchain "$toolchain"
          done
          
          # Generate build arguments
          ARCH=$(echo '${{ toJSON(matrix.CONFIG.params) }}' | jq -r '.ARCH')
          CC=$(echo '${{ toJSON(matrix.CONFIG.params) }}' | jq -r '.CC')
          
          # Base build args
          ARGS="-j$(nproc) O=${{ env.OUT_DIR }} ARCH=$ARCH"
          
          # Configure compiler
          if [ -n "$CC" ]; then
            if [[ "$CC" == *"/"* ]]; then
              CC="${{ env.WORKSPACE }}/$CC"
            fi
            
            if [ "${{ env.ENABLE_CCACHE }}" = "true" ]; then
              ARGS="$ARGS CC=\"ccache $CC\""
            else
              ARGS="$ARGS CC=$CC"
            fi
          fi
          
          # Add external commands
          echo '${{ toJSON(matrix.CONFIG.params) }}' | jq -r '.externalCommands | to_entries[] | "\(.key)=\(.value)"' | while read -r cmd; do
            key=$(echo "$cmd" | cut -d= -f1)
            value=$(echo "$cmd" | cut -d= -f2)
            
            if [[ "$value" == *"/"* ]]; then
              value="${{ env.WORKSPACE }}/$value"
            fi
            
            ARGS="$ARGS $key=$value"
          done
          
          echo "arch=$ARCH" >> $GITHUB_OUTPUT
          echo "args=$ARGS" >> $GITHUB_OUTPUT
      
      - name: Setup KernelSU
        if: ${{ env.ENABLE_KERNELSU == 'true' }}
        working-directory: ${{ env.KERNEL_NAME }}
        env:
          ARCH: ${{ steps.toolchains.outputs.arch }}
        run: |
          # Clean any existing KernelSU installations
          rm -rf ./KernelSU ./drivers/kernelsu
          
          # Install KernelSU
          curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
          
          # Add necessary kernel config options
          echo "CONFIG_KPROBES=y" >> arch/${{ env.ARCH }}/configs/${{ env.KERNEL_DEFCONFIG }}
          echo "CONFIG_HAVE_KPROBES=y" >> arch/${{ env.ARCH }}/configs/${{ env.KERNEL_DEFCONFIG }}
          echo "CONFIG_KPROBE_EVENTS=y" >> arch/${{ env.ARCH }}/configs/${{ env.KERNEL_DEFCONFIG }}
      
      - name: Build Kernel
        working-directory: ${{ env.KERNEL_NAME }}
        env:
          ARGS: ${{ steps.toolchains.outputs.args }}
        run: |
          # Set build identifiers
          export KBUILD_BUILD_HOST=GithubActions
          export KBUILD_BUILD_USER=$(echo ${{ github.actor }} | tr A-Z a-z)
          
          # Build
          make ${{ env.ARGS }} ${{ env.KERNEL_DEFCONFIG }}
          make ${{ env.ARGS }}
      
      - name: Upload Kernel Artifacts
        uses: ./.github/actions/upload-kernel-artifacts
        with:
          kernel_name: ${{ env.KERNEL_NAME }}
          build_date: ${{ env.BUILD_DATE }}
          out_dir: ${{ env.OUT_DIR }}
          arch: ${{ steps.toolchains.outputs.arch }}
      
      - name: Package with AnyKernel3
        if: ${{ env.USE_ANYKERNEL3 == 'true' }}
        id: anykernel
        env:
          ARCH: ${{ steps.toolchains.outputs.arch }}
          AK3_CONFIG: ${{ toJSON(matrix.CONFIG.AnyKernel3) }}
        run: |
          # Determine which AnyKernel3 repo to use
          if echo '${{ env.AK3_CONFIG }}' | jq -e 'has("custom")' > /dev/null; then
            REPO=$(echo '${{ env.AK3_CONFIG }}' | jq -r '.custom.repo')
            BRANCH=$(echo '${{ env.AK3_CONFIG }}' | jq -r '.custom.branch')
            git clone --recursive --depth=1 -j $(nproc) --branch $BRANCH $REPO AnyKernel3
            echo "Using custom AnyKernel3 from $REPO"
          else
            git clone --recursive --depth=1 -j $(nproc) https://github.com/osm0sis/AnyKernel3 AnyKernel3
            # Configure AnyKernel3 for universal compatibility
            sed -i 's/do.devicecheck=1/do.devicecheck=0/g' AnyKernel3/anykernel.sh
            sed -i 's!BLOCK=/dev/block/platform/omap/omap_hsmmc.0/by-name/boot;!BLOCK=auto;!g' AnyKernel3/anykernel.sh
            sed -i 's/is_slot_device=0;/is_slot_device=auto;/g' AnyKernel3/anykernel.sh
            echo "Using default AnyKernel3 from osm0sis/AnyKernel3"
          fi
          
          # Copy kernel files to AnyKernel3 directory
          BOOT_DIR="${{ env.OUT_DIR }}/arch/${{ env.ARCH }}/boot"
          
          # Copy available kernel artifacts
          [ -f "$BOOT_DIR/Image.gz-dtb" ] && cp -f "$BOOT_DIR/Image.gz-dtb" AnyKernel3/
          [ -f "$BOOT_DIR/Image" ] && cp -f "$BOOT_DIR/Image" AnyKernel3/
          [ -f "$BOOT_DIR/Image.gz" ] && cp -f "$BOOT_DIR/Image.gz" AnyKernel3/
          [ -f "$BOOT_DIR/dtbo" ] && cp -f "$BOOT_DIR/dtbo" AnyKernel3/
          [ -f "$BOOT_DIR/dtbo.img" ] && cp -f "$BOOT_DIR/dtbo.img" AnyKernel3/
          
          # Create ZIP package
          PACKAGE_NAME="AnyKernel3-${{ env.KERNEL_NAME }}-${{ env.BUILD_DATE }}"
          cd AnyKernel3/
          zip -q -r ../$PACKAGE_NAME.zip *
          
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
      
      - name: Upload AnyKernel3 Package
        if: ${{ env.USE_ANYKERNEL3 == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.anykernel.outputs.package_name }}
          path: AnyKernel3/*
          retention-days: 14
      
      - name: Create GitHub Release
        if: ${{ env.USE_ANYKERNEL3 == 'true' && env.CREATE_RELEASE == 'true' }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.BUILD_DATE }}-${{ github.run_number }}
          name: "${{ env.KERNEL_NAME }} Kernel v${{ env.BUILD_DATE }}.${{ github.run_number }}"
          files: ${{ steps.anykernel.outputs.package_name }}.zip
          generate_release_notes: true
          draft: false
          prerelease: false
